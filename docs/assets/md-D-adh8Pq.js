import{o as n,c as s,k as i,e,aa as t,q as u,s as h,B as o}from"./modules/vue-D8PwQFku.js";import{I as d}from"./slidev/default-D0flozwn.js";import{u as p,f as c}from"./slidev/context-BZpXMt3t.js";import"./index-BDD5mVii.js";import"./modules/shiki-Czx2DoIt.js";const $={__name:"slides.md__slidev_23",setup(m){const{$slidev:f,$nav:g,$clicksContext:r,$clicks:y,$page:b,$renderContext:k,$frontmatter:l}=p();return r.setup(),(_,a)=>(n(),s(d,u(h(o(c)(o(l),22))),{default:i(()=>a[0]||(a[0]=[e("h1",null,"A vision => Mulder: an extended Scully powered by DSLs",-1),e("h3",null,"Why scully ?",-1),e("ul",null,[e("li",null,[t("I’m a fan of "),e("a",{href:"https://angular.io/",target:"_blank"},"Angular"),t(" over "),e("a",{href:"https://reactjs.org/",target:"_blank"},"React"),t(" or "),e("a",{href:"https://vuejs.org/",target:"_blank"},"VueJS"),t(", I am not able to explain it, maybe it’s because they built the framework on top of the TypeScript language features making the handling of the framework abstractions extremely simple and intuitive. As a result, I built "),e("em",null,"Mulder"),t(" on top of "),e("a",{href:"https://scully.io/",target:"_blank"},"Scully"),t(".")])],-1),e("h3",null,"Mulder: Empowering the JAMStack with DSLs",-1),e("ul",null,[e("li",null,[t("The idea of "),e("em",null,"Mulder"),t(" is to provide a set of web components and scully plugins to consume data structured within DSLs that are parsed directly into TypeScript either at the time of passing through the CI for static data or at the time of loading the data at the time of loading the page for dynamic data. The scenario for the enduser is the following, any "),e("em",null,"txt"),t(" file hosted on github, gitlab, hackmd that can be updated on the fly by the user. This txt file is parsed on the fly by a combinatorial parser within the application in order to be consumed in the component it uses.")])],-1)])),_:1},16))}};export{$ as default};
